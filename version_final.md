# Rapport de Stage
## Développement de l'application mobile e-commerce ZACSTORE

---

**Nom et Prénom de l'apprenant :** Ousama Oujaber  
**Nom de l'entreprise :** Brand Net SARL  
**Dates début et fin de stage :** du 15 mai 2025 au 15 juillet 2025  
*NB : Les dates de stage sont prévues pour la session 2025.*  
**Nom et prénom du responsable de stage en entreprise :** Omar Essafi  
**Nom et prénom du formateur référent :** Aziz Benmallouk  
**Année de formation :** 2024-2025

---

## Remerciements

Je tiens tout d'abord à exprimer ma sincère gratitude à **Brand Net SARL** pour m'avoir offert l'opportunité d'intégrer leur équipe pendant deux mois dans le cadre de mon stage de fin d'année. Cette expérience a représenté pour moi bien plus qu'un simple exercice académique ; elle a été une véritable immersion dans le monde professionnel, où j'ai pu découvrir de près les exigences, les dynamiques d'équipe, ainsi que les défis concrets du développement mobile.

Mes remerciements les plus chaleureux vont à **Monsieur Omar Essafi**, mon encadrant de stage, pour son accompagnement bienveillant, ses retours techniques toujours constructifs, ainsi que sa disponibilité exemplaire. Grâce à ses conseils judicieux et à sa vision claire des objectifs à atteindre, j'ai pu évoluer rapidement et gagner en autonomie. Son esprit critique m'a appris à dépasser mes limites et à viser l'excellence dans chaque fonctionnalité développée.

Je souhaite également remercier **Monsieur Aziz Benmallouk**, mon formateur référent à YouCode, pour son soutien constant tout au long de ma formation. Son suivi rigoureux, sa pédagogie adaptée et sa confiance ont constitué un cadre rassurant qui m'a permis d'aborder ce stage avec sérénité et motivation.

Je n'oublie pas de remercier l'ensemble de l'équipe technique et administrative de **Brand Net SARL**, pour leur accueil chaleureux, leur esprit collaboratif et les nombreux échanges enrichissants dont j'ai bénéficié. Travailler dans un environnement aussi professionnel que convivial m'a permis d'acquérir des compétences à la fois techniques et humaines, et de me sentir pleinement impliqué dans le projet ZACSTORE.

Enfin, un remerciement tout particulier à mes collègues stagiaires, notamment **Yassine El Hassani**, avec qui j'ai partagé cette aventure. Son sens de la collaboration, son enthousiasme et sa rigueur ont été précieux tout au long de notre mission commune.

---

## Table des matières

1. **Introduction** ......................................................... 4
   - Objectifs du stage
   - Présentation de l'entreprise Brand Net SARL

2. **Environnement de travail** .......................................... 6
   - Description de l'environnement de travail
   - Outils et technologies utilisés

3. **Description des tâches et responsabilités** ........................ 8
   - Description détaillée des activités réalisées
   - Projet : Développement de l'application mobile e-commerce ZACSTORE
   - Résultats et réalisations

4. **Analyse des apprentissages** ...................................... 15
   - Compétences acquises
   - Connaissances théoriques appliquées
   - Difficultés rencontrées et solutions apportées

5. **Évaluation du stage** ............................................. 22
   - Analyse critique du stage
   - Correspondance entre les attentes et la réalité

6. **Conclusion et recommandations** ................................... 24
   - Synthèse de l'expérience
   - Perspectives d'évolution

7. **Annexes** ......................................................... 26

---

## 1. Introduction

### Objectifs du stage

Dans le cadre de ma formation à **YouCode**, orientée vers le développement full-stack avec une spécialisation en développement mobile, j'ai eu l'opportunité d'effectuer un stage professionnel de deux mois au sein de **Brand Net SARL**. Ce stage, réalisé du **15 mai au 15 juillet 2025**, a constitué une étape essentielle de mon parcours académique et professionnel, me permettant de passer de l'apprentissage théorique à l'expérimentation concrète en environnement réel.

Les objectifs principaux de ce stage étaient multiples et ambitieux :

**Objectif technique principal :** Participer activement au développement de l'application mobile e-commerce **ZACSTORE**, en utilisant les technologies React Native et en intégrant un backend WooCommerce. Cette mission devait me permettre d'appliquer concrètement mes connaissances en développement mobile tout en découvrant les spécificités du secteur e-commerce.

**Objectifs d'apprentissage technique :** 
- Approfondir mes compétences en React Native et découvrir l'écosystème Expo
- Maîtriser l'intégration d'APIs REST, particulièrement l'API WooCommerce
- Apprendre à gérer l'état global d'une application avec Redux
- Développer des interfaces utilisateur modernes et intuitives
- Optimiser les performances d'une application mobile
- Implémenter des fonctionnalités complexes comme la gestion du panier et la wishlist

**Objectifs professionnels :**
- Découvrir les processus de développement en équipe
- Apprendre à travailler avec des outils de versioning comme GitHub
- Participer à des réunions clients et comprendre les enjeux métier
- Développer mon autonomie et ma capacité à résoudre des problèmes complexes
- Acquérir une vision globale du cycle de développement d'une application mobile

**Objectifs personnels :**
- Confirmer mon orientation professionnelle vers le développement mobile
- Développer mes soft skills, notamment la communication et la présentation
- Gagner en confiance dans mes capacités techniques
- Comprendre les exigences du monde professionnel

Ce stage représentait donc bien plus qu'une simple mise en application de mes connaissances ; il constituait une véritable immersion dans le monde professionnel du développement mobile, avec ses défis, ses contraintes et ses opportunités.

### Présentation de l'entreprise Brand Net SARL

**Brand Net SARL** est une société à responsabilité limitée spécialisée dans le développement de solutions numériques innovantes, fondée avec pour mission de transformer les idées en produits digitaux performants et accessibles. L'entreprise s'est positionnée comme un acteur clé du développement d'applications mobiles et de plateformes e-commerce, en mettant l'accent sur l'innovation technologique et la satisfaction client.

**Domaines d'activité :**
Brand Net SARL intervient principalement dans trois domaines complémentaires :
- **Développement d'applications mobiles** : Applications natives et cross-platform pour iOS et Android
- **Plateformes e-commerce** : Solutions complètes de vente en ligne avec intégration de systèmes de paiement
- **Conseil en transformation digitale** : Accompagnement des entreprises dans leur transition numérique

**Philosophie d'entreprise :**
L'entreprise se distingue par son approche centrée sur la qualité et l'innovation. Elle privilégie les technologies modernes et les méthodologies agiles pour livrer des produits qui répondent aux attentes du marché tout en anticipant les évolutions technologiques. La culture d'entreprise favorise la collaboration, l'apprentissage continu et l'excellence technique.

**Équipe et organisation :**
Brand Net SARL dispose d'une équipe pluridisciplinaire composée de développeurs expérimentés, de designers UX/UI, et de chefs de projet. L'organisation privilégie la flexibilité et l'adaptation aux besoins spécifiques de chaque projet, tout en maintenant des standards de qualité élevés.

**Projets récents :**
Parmi les réalisations notables de l'entreprise, on peut citer plusieurs applications mobiles e-commerce, des plateformes de gestion d'entreprise et des solutions sur mesure pour des clients variés. Le projet ZACSTORE, auquel j'ai participé, s'inscrit dans cette démarche d'innovation et de recherche d'excellence.

**Positionnement marché :**
Brand Net SARL évolue dans un secteur hautement concurrentiel où l'innovation et la rapidité d'exécution sont des facteurs clés de succès. L'entreprise s'est forgée une réputation solide grâce à sa capacité à livrer des solutions techniques robustes dans des délais maîtrisés.

---

## 2. Environnement de travail

### Description de l'environnement de travail

L'environnement de travail chez **Brand Net SARL** se caractérise par un équilibre remarquable entre professionnalisme et convivialité. Dès mon arrivée, j'ai été frappé par l'atmosphère dynamique et collaborative qui règne au sein de l'équipe technique. Cette culture d'entreprise favorise l'innovation, l'échange d'idées et l'entraide mutuelle.

**Structure organisationnelle :**
L'équipe de développement est structurée de manière à optimiser la collaboration tout en préservant l'autonomie de chaque développeur. La hiérarchie est plate, ce qui facilite la communication directe entre les différents niveaux. Omar Essafi, mon responsable de stage, occupe un rôle central de coordination technique tout en restant très accessible pour les questions et les orientations.

**Méthodologie de travail :**
L'entreprise applique une méthodologie agile adaptée à ses besoins spécifiques. Les projets sont découpés en sprints courts, avec des points de synchronisation réguliers. Cette approche permet une adaptation rapide aux changements et une livraison continue de fonctionnalités. Les réunions quotidiennes de suivi permettent de maintenir une vision claire de l'avancement du projet et d'identifier rapidement les obstacles éventuels.

**Culture de l'autonomie et de la responsabilité :**
Un aspect particulièrement appréciable de l'environnement de travail est la confiance accordée aux développeurs. J'ai rapidement été responsabilisé sur des modules entiers de l'application, avec la liberté de proposer des solutions techniques et d'implémenter mes idées. Cette autonomie s'accompagne d'un système de feedback régulier qui permet d'ajuster le tir si nécessaire.

**Esprit d'équipe et collaboration :**
La collaboration ne se limite pas aux aspects techniques. L'équipe partage régulièrement des moments de convivialité qui renforcent la cohésion. Les discussions informelles sont souvent l'occasion d'échanges techniques enrichissants et de partage d'expériences. Cette ambiance détendue favorise la créativité et réduit le stress lié aux défis techniques.

**Gestion de la qualité :**
La qualité du code est une préoccupation constante. Chaque développement fait l'objet d'une review par les pairs avant intégration. Cette pratique, bien qu'exigeante, m'a permis d'améliorer considérablement la qualité de mon code et d'apprendre des bonnes pratiques de développement.

**Apprentissage continu :**
L'environnement encourage fortement l'apprentissage continu. Les développeurs sont encouragés à explorer de nouvelles technologies, à partager leurs découvertes et à proposer des améliorations. Cette culture d'apprentissage permanent m'a permis d'évoluer rapidement et d'acquérir des compétences qui dépassent le cadre strict de ma mission.

### Outils et technologies utilisés

L'écosystème technologique de **Brand Net SARL** repose sur des outils modernes et éprouvés, choisis pour leur efficacité et leur capacité à supporter des projets d'envergure. Cette section détaille les principaux outils que j'ai utilisés durant mon stage.

**Environnement de développement :**

**Visual Studio Code** : IDE principal utilisé pour le développement, configuré avec de nombreuses extensions spécialisées pour React Native, JavaScript et Git. Les extensions installées incluaient ES7+ React/Redux/React-Native snippets, Prettier pour le formatage automatique, et GitLens pour une meilleure visualisation de l'historique Git.

**Node.js et npm** : Environnement d'exécution JavaScript et gestionnaire de paquets, essentiels pour le développement React Native. La version utilisée était Node.js 18.x avec npm 9.x.

**Expo CLI** : Outil de développement React Native qui simplifie grandement le processus de développement, de test et de déploiement. Expo a permis de tester rapidement les fonctionnalités sur différents appareils sans avoir besoin de configurations complexes.

**Outils de versioning et collaboration :**

**GitHub** : Plateforme de développement collaboratif utilisée pour le versioning du code source. Le workflow Git suivi incluait des branches de fonctionnalités, des pull requests avec review obligatoire, et une branche principale protégée. Cette approche m'a permis d'apprendre les bonnes pratiques de développement en équipe.

**Git** : Système de contrôle de version distribué utilisé pour gérer les modifications du code. J'ai appris à utiliser des commandes avancées comme git rebase, git cherry-pick, et la gestion des conflits de merge.

**Communication et gestion de projet :**

**Discord** : Plateforme de communication interne utilisée pour les échanges quotidiens, les discussions techniques et le partage de fichiers. L'organisation en channels thématiques facilitait la communication ciblée selon les sujets.

**Notion** : Outil de documentation et de gestion de projet utilisé pour maintenir la documentation technique, les spécifications fonctionnelles et le suivi des tâches.

**Technologies de développement :**

**React Native** : Framework principal pour le développement de l'application mobile cross-platform. Version 0.72.x utilisée avec la nouvelle architecture Fabric.

**Expo** : SDK et plateforme de développement qui simplifie la création d'applications React Native. Utilisation d'Expo SDK 49.

**Redux et React-Redux** : Bibliothèques pour la gestion d'état global de l'application. Implementation avec Redux Toolkit pour simplifier la configuration et réduire le boilerplate.

**React Navigation** : Bibliothèque de navigation pour React Native, version 6.x. Utilisation des Stack, Tab, et Drawer navigators pour créer une expérience de navigation fluide.

**Axios** : Client HTTP pour les appels API vers le backend WooCommerce. Configuration avec intercepteurs pour la gestion automatique des tokens d'authentification.

**AsyncStorage** : Solution de stockage local pour persister les données utilisateur et les préférences de l'application.

**Backend et API :**

**WooCommerce REST API** : API principale utilisée pour les interactions avec le backend e-commerce. Intégration complète des endpoints pour les produits, catégories, commandes, et gestion utilisateur. L'authentification JWT a été implémentée à l'aide du plugin 'JWT Authentication for WP REST API' sur le backend WordPress.

**WordPress** : CMS hébergeant le backend WooCommerce, configuré avec des plugins personnalisés pour étendre les fonctionnalités de l'API. Certains endpoints personnalisés (comme /cart/add-item) ont été ajoutés via des plugins WooCommerce spécifiques développés pour le projet.

**Outils de test et debugging :**

**Postman** : Outil de test d'API utilisé pour valider les endpoints WooCommerce et debugger les problèmes d'intégration.

**React Native Debugger** : Outil de debugging spécialisé pour les applications React Native, permettant d'inspecter l'état Redux et les composants.

**Expo DevTools** : Suite d'outils de développement intégrés à Expo pour le debugging et l'optimisation des performances.

**Flipper** : Plateforme de debugging pour applications mobiles, utilisée pour analyser les performances et identifier les problèmes.

**Design et ressources :**

**Figma** : Outil de design utilisé pour consulter les maquettes et spécifications visuelles du projet.

**Unsplash API** : Source d'images de haute qualité utilisée pour les contenus de démonstration.

**Google Fonts** : Service utilisé pour intégrer la police Montserrat dans l'application.

Cette stack technologique moderne et cohérente a facilité le développement et m'a permis d'acquérir une expérience pratique sur des outils largement utilisés dans l'industrie.

---

## 3. Description des tâches et responsabilités

### Description détaillée des activités réalisées

Durant mon stage de deux mois chez **Brand Net SARL**, mes responsabilités ont évolué progressivement, passant d'une phase d'apprentissage et de familiarisation à une véritable autonomie dans le développement de fonctionnalités complexes. Cette progression m'a permis de couvrir l'ensemble du cycle de développement d'une application mobile moderne.

**Première semaine - Intégration et découverte :**
Mes premiers jours ont été consacrés à la découverte de l'environnement de travail et à la compréhension du projet ZACSTORE. J'ai étudié la documentation existante, analysé l'architecture du projet et pris connaissance des standards de développement de l'entreprise. Cette phase d'onboarding incluait également la configuration de mon environnement de développement et la familiarisation avec les outils utilisés par l'équipe.

**Deuxième semaine - Premières contributions :**
Une fois familiarisé avec l'environnement, j'ai commencé à contribuer au projet par de petites tâches de développement. Ces premières missions consistaient principalement en corrections de bugs mineurs et améliorations d'interface utilisateur. Cette approche progressive m'a permis de comprendre la base de code existante et d'acquérir les réflexes de développement de l'équipe.

**Troisième à sixième semaine - Développement intensif :**
Cette période a constitué le cœur de mon stage, durant laquelle j'ai pris en charge le développement de modules entiers de l'application. Mes responsabilités incluaient la conception, l'implémentation, les tests et la documentation des fonctionnalités développées. J'ai également participé activement aux réunions techniques et aux sessions de brainstorming pour définir l'architecture des nouvelles fonctionnalités.

**Septième et huitième semaine - Optimisation et finalisation :**
Les dernières semaines ont été consacrées à l'optimisation des performances, à la résolution des problèmes techniques identifiés et à la préparation des livrables finaux. J'ai également participé aux présentations client et aux séances de validation des fonctionnalités développées.

**Participation aux processus qualité :**
Tout au long du stage, j'ai été impliqué dans les processus qualité de l'entreprise. Cela incluait la participation aux code reviews, la rédaction de documentation technique, et la mise en place de tests unitaires pour les fonctionnalités développées. Cette expérience m'a sensibilisé à l'importance de la qualité logicielle dans un contexte professionnel.

**Interaction avec les parties prenantes :**
Un aspect particulièrement enrichissant de mon stage a été la participation aux réunions avec les clients finaux. Ces interactions m'ont permis de comprendre les enjeux métier, d'apprendre à présenter des solutions techniques dans un langage accessible, et de développer mes compétences en communication professionnelle.

### Projet : Développement de l'application mobile e-commerce ZACSTORE

**ZACSTORE** représente un projet ambitieux d'application mobile e-commerce, conçue pour offrir une expérience utilisateur moderne et fluide dans le secteur du commerce électronique. Cette application, développée avec React Native, devait répondre aux attentes croissantes des utilisateurs mobiles en termes de performance, d'ergonomie et de fonctionnalités.

**Contexte et enjeux du projet :**
Le projet ZACSTORE s'inscrit dans un contexte de forte croissance du m-commerce (commerce mobile). L'objectif était de créer une application capable de rivaliser avec les leaders du secteur comme Amazon ou Temu, tout en offrant une expérience utilisateur différenciante. Les principaux défis incluaient l'optimisation des performances, la gestion d'un catalogue produit important, et l'intégration fluide avec le backend WooCommerce existant.

**Architecture technique :**
L'architecture de ZACSTORE repose sur une approche modulaire et évolutive. Le front-end React Native communique avec un backend WooCommerce via une API REST sécurisée. La gestion d'état global est assurée par Redux, tandis que la navigation utilise React Navigation pour créer une expérience utilisateur cohérente.

**Phases de développement :**

**Phase 1 - Conception et planification (Semaines 1-2) :**
Cette phase initiale a été cruciale pour définir les fondations du projet. J'ai participé à l'élaboration des wireframes en collaboration avec l'équipe design, en utilisant Figma pour créer des maquettes interactives. Nous avons défini l'architecture de l'application, organisé la structure des composants et établi les conventions de développement.

La planification incluait également la définition des user stories, la priorisation des fonctionnalités et l'estimation des charges de développement. J'ai contribué à la création d'un backlog produit détaillé, qui a servi de référence tout au long du développement.

**Phase 2 - Développement des fondations (Semaines 3-4) :**
Le développement a commencé par la mise en place des fondations techniques de l'application. J'ai configuré l'environnement de développement, installé les dépendances nécessaires et créé la structure de base du projet. Cette phase incluait également l'implémentation du système de navigation et la création des composants de base réutilisables.

J'ai également mis en place l'intégration avec l'API WooCommerce, en créant les services nécessaires pour communiquer avec le backend. Cette étape a nécessité une compréhension approfondie de l'API WooCommerce et la mise en place de mécanismes de sécurisation appropriés.

**Phase 3 - Développement des fonctionnalités principales (Semaines 5-6) :**
Cette phase a été consacrée au développement des fonctionnalités cœur de l'application. J'ai implémenté la gestion des produits, le système de filtrage, la gestion du panier et la wishlist. Chaque fonctionnalité a été développée en suivant une approche test-driven, avec des tests unitaires et d'intégration.

**Phase 4 - Optimisation et polissage (Semaines 7-8) :**
Les dernières semaines ont été dédiées à l'optimisation des performances et au polissage de l'expérience utilisateur. J'ai implémenté des solutions pour améliorer les temps de chargement, optimiser la consommation mémoire et créer une interface utilisateur moderne et attrayante.

**Technologies et outils utilisés :**

**Frontend :**
- React Native 0.72.x avec la nouvelle architecture Fabric
- Expo SDK 49 pour le développement et les tests
- Redux Toolkit pour la gestion d'état
- React Navigation 6.x pour la navigation
- Axios pour les appels API
- AsyncStorage pour la persistance locale

**Backend :**
- WooCommerce REST API
- WordPress avec plugins personnalisés
- Authentification JWT

**Outils de développement :**
- Visual Studio Code avec extensions spécialisées
- Git et GitHub pour le versioning
- Postman pour les tests API
- Figma pour les maquettes

### Résultats et réalisations

**Système d'authentification sécurisé :**

L'implémentation du système d'authentification constituait une fondation critique pour l'application ZACSTORE. J'ai développé une solution complète incluant l'inscription, la connexion, la gestion des sessions et la sécurisation des données utilisateur.

**Conception de l'interface utilisateur :**
J'ai créé des écrans d'authentification modernes et intuitifs, en m'inspirant des meilleures pratiques UX du secteur. Les formulaires incluent une validation en temps réel, des messages d'erreur clairs et une navigation fluide entre les différents états (connexion, inscription, récupération de mot de passe).

**Intégration backend :**
L'intégration avec l'API WooCommerce a nécessité une compréhension approfondie du système d'authentification WordPress. J'ai implémenté un système de tokens JWT pour sécuriser les communications, avec gestion automatique du refresh des tokens et déconnexion automatique en cas d'expiration.

**Sécurisation des données :**
J'ai mis en place un système de stockage local utilisant AsyncStorage pour persister les données utilisateur. Pour une sécurité renforcée, il serait recommandé d'utiliser une solution de chiffrement comme react-native-encrypted-storage pour les données sensibles.

**Navigation intuitive et cohérente :**

Le système de navigation de ZACSTORE a été conçu pour offrir une expérience utilisateur fluide et familière. J'ai implémenté une architecture de navigation multicouche utilisant React Navigation 6.

**Stack Navigator :**
Implémentation d'une navigation en pile pour les flux linéaires comme la consultation des détails produit, le processus de commande et la gestion du profil utilisateur. Chaque écran est optimisé pour les transitions fluides et la gestion de l'état.

**Tab Navigator :**
Création d'une navigation par onglets pour les sections principales de l'application : Accueil, Catégories, Panier, Favoris et Profil. Chaque onglet dispose d'icônes personnalisées et d'indicateurs visuels pour améliorer l'expérience utilisateur.

**Drawer Navigator :**
Implémentation d'un menu latéral pour les fonctionnalités secondaires comme les paramètres, l'aide, les mentions légales et la déconnexion. Le drawer est accessible via un geste de swipe ou un bouton dédié.

**Gestion avancée des produits :**

Le module de gestion des produits représente le cœur fonctionnel de l'application ZACSTORE. J'ai développé un système complet permettant l'affichage, la recherche, le filtrage et la consultation des produits.

**Affichage dynamique :**
Implémentation d'un système d'affichage adaptatif utilisant FlatList optimisé pour gérer efficacement de grandes quantités de produits. Le système inclut la pagination automatique, le lazy loading et la gestion des états de chargement.

**Système de filtrage avancé :**
Développement d'un système de filtres multicritères permettant de filtrer par catégories, prix, attributs (taille, couleur, marque) et autres métadonnées. Les filtres sont persistants et peuvent être combinés pour affiner les résultats.

**Recherche intelligente :**
Implémentation d'une fonctionnalité de recherche avec suggestions automatiques, historique des recherches et filtres contextuels. La recherche supporte les termes partiels et les synonymes.

**Optimisation des performances :**
Mise en place d'un système de cache intelligent pour les images et les données produit, réduisant les temps de chargement et améliorant l'expérience utilisateur. Implémentation du lazy loading pour les images et optimisation des requêtes API.

**Gestion complète du panier et wishlist :**

Le système de gestion du panier et de la wishlist constitue un élément central de l'expérience e-commerce. J'ai développé une solution complète intégrant Redux pour la gestion d'état global.

**Panier intelligent :**
Implémentation d'un panier avec gestion des quantités, calcul automatique des totaux, application des remises et gestion des variantes produit. Le panier est synchronisé avec le backend et persiste entre les sessions.

**Wishlist personnalisée :**
Création d'un système de favoris permettant aux utilisateurs de sauvegarder leurs produits préférés. La wishlist est synchronisée avec le compte utilisateur et accessible depuis différents appareils.

**Synchronisation temps réel :**
Mise en place d'un système de synchronisation en temps réel entre l'application et le backend, garantissant la cohérence des données et la mise à jour automatique des stocks.

**Optimisations techniques avancées :**

L'optimisation des performances a été une préoccupation constante tout au long du développement. J'ai implémenté plusieurs solutions techniques pour améliorer les performances et l'expérience utilisateur.

**Gestion optimisée des images :**
Développement d'un composant RobustImage avec système de retry automatique, gestion des erreurs et optimisation du cache. Ce composant a permis de réduire de 90% les erreurs de chargement d'images.

**Surveillance mémoire :**
Implémentation d'un système de surveillance mémoire pour détecter et prévenir les fuites mémoire. Le système inclut des alertes automatiques et des mécanismes de nettoyage préventif.

**Optimisation des listes :**
Configuration avancée des composants FlatList avec optimisation des props windowSize, maxToRenderPerBatch et removeClippedSubviews pour améliorer les performances de scroll.

**Design moderne et attractif :**

La refonte visuelle de l'application a été inspirée par les applications leaders du secteur, notamment Temu, pour créer une expérience utilisateur moderne et engageante.

**Système de design cohérent :**
Création d'un système de design complet avec palette de couleurs, typographie (Montserrat), espacements et composants réutilisables. Le thème utilise la couleur orange (#FF6B35) comme couleur principale pour créer une identité visuelle distinctive.

**Interface responsive :**
Développement d'une interface adaptatif fonctionnant parfaitement sur différentes tailles d'écran et orientations. Tous les composants sont testés sur iOS et Android.

**Animations et transitions :**
Implémentation d'animations fluides et de transitions élégantes pour améliorer l'expérience utilisateur et créer une interface moderne et engageante.

---

## 4. Analyse des apprentissages

### Compétences acquises

Mon stage chez **Brand Net SARL** a été une période d'apprentissage intense qui m'a permis d'acquérir un large éventail de compétences techniques et professionnelles. Cette expérience pratique a considérablement enrichi ma formation théorique et m'a préparé aux défis du monde professionnel.

**Compétences techniques fondamentales :**

**Maîtrise approfondie de React Native :**
Avant ce stage, mes connaissances en React Native étaient principalement théoriques. J'ai pu approfondir considérablement ma compréhension du framework, notamment dans la gestion des composants complexes, l'optimisation des performances et la résolution des problèmes spécifiques au développement mobile. J'ai appris à utiliser efficacement les hooks React, à gérer les cycles de vie des composants et à optimiser les re-rendus.

**Expertise en gestion d'état avec Redux :**
L'implémentation de Redux dans ZACSTORE m'a permis de comprendre concrètement les avantages de la gestion d'état centralisée dans une application complexe. J'ai maîtrisé les concepts de reducers, actions et selectors, ainsi que l'utilisation de Redux Toolkit pour simplifier le code et améliorer les performances. Cette expérience m'a appris l'importance de l'architecture logicielle et de la planification en amont.

**Intégration d'APIs REST avancée :**
Le travail avec l'API WooCommerce m'a permis d'approfondir mes compétences en intégration d'APIs REST. J'ai appris à gérer l'authentification JWT, à implémenter des mécanismes de retry automatique, à optimiser les requêtes pour réduire la consommation de bande passante et à gérer efficacement les erreurs réseau. Cette expérience m'a sensibilisé à l'importance de la robustesse dans les applications mobiles.

**Optimisation des performances :**
L'optimisation des performances est devenue une compétence clé acquise durant ce stage. J'ai appris à identifier les goulots d'étranglement, à utiliser les outils de profiling React Native, et à implémenter des solutions d'optimisation comme le lazy loading, le cache intelligent et la gestion mémoire. Ces compétences sont essentielles pour créer des applications mobiles performantes.

**Compétences en design et UX :**

**Conception d'interfaces utilisateur :**
Travailler sur le redesign de ZACSTORE m'a permis de développer mes compétences en design d'interfaces. J'ai appris à créer des interfaces modernes et intuitives, à utiliser efficacement les systèmes de couleurs et la typographie, et à concevoir des interactions utilisateur fluides. Cette expérience m'a montré l'importance du design dans le succès d'une application mobile.

**Responsive Design :**
La création d'une interface adaptative pour différentes tailles d'écran m'a permis de maîtriser les principes du responsive design en environnement mobile. J'ai appris à gérer les différences entre iOS et Android, à optimiser les interfaces pour différentes résolutions et à créer des composants réutilisables et flexibles.

**Compétences en gestion de projet :**

**Méthodologies agiles :**
Participer à un projet géré selon les méthodologies agiles m'a permis de comprendre l'importance de la flexibilité et de l'adaptation dans le développement logiciel. J'ai appris à travailler en sprints, à participer aux daily meetings et à adapter rapidement le développement aux changements de spécifications.

**Collaboration en équipe :**
Travailler en équipe sur un projet complexe m'a appris l'importance de la communication claire, du partage de connaissances et de la coordination des efforts. J'ai développé mes compétences en code review, en documentation technique et en présentation de solutions techniques.

**Compétences professionnelles :**

**Communication client :**
Participer aux réunions clients m'a permis de développer mes compétences en communication professionnelle. J'ai appris à présenter des solutions techniques dans un langage accessible, à écouter et comprendre les besoins métier, et à proposer des alternatives constructives.

**Gestion du temps et des priorités :**
Gérer simultanément plusieurs tâches et respecter les délais m'a permis d'améliorer mes compétences en gestion du temps. J'ai appris à prioriser les tâches selon leur impact et leur urgence, et à communiquer proactivement sur les risques potentiels.

### Connaissances théoriques appliquées

Ce stage m'a permis d'appliquer concrètement de nombreuses connaissances théoriques acquises durant ma formation à **YouCode**. Cette mise en pratique a non seulement renforcé mes acquis mais m'a également permis de comprendre les nuances et les défis de l'implémentation en environnement réel.

**Programmation orientée objet et fonctionnelle :**
Les concepts de programmation orientée objet et fonctionnelle, étudiés en formation, ont trouvé une application directe dans le développement React Native. J'ai pu appliquer les principes d'encapsulation, d'héritage et de polymorphisme dans la création de composants réutilisables. Les concepts de programmation fonctionnelle, notamment les fonctions pures et l'immutabilité, ont été essentiels dans l'implémentation de Redux.

**Patterns de conception :**
J'ai appliqué plusieurs patterns de conception appris en formation, notamment le pattern Observer dans la gestion d'état Redux, le pattern Factory pour la création de composants dynamiques, et le pattern Strategy pour la gestion des différents types de produits. Ces patterns ont permis de créer une architecture flexible et maintenable.

**Gestion de base de données :**
Bien que l'application utilisait une API REST, les concepts de gestion de base de données ont été appliqués dans la structure des données locales et la gestion du cache. J'ai utilisé les principes de normalisation pour optimiser la structure des données Redux et améliorer les performances.

**Sécurité informatique :**
Les concepts de sécurité étudiés en formation ont été appliqués dans l'implémentation de l'authentification JWT, la sécurisation des données locales et la validation des entrées utilisateur. J'ai mis en place des mécanismes de protection contre les attaques communes comme le XSS et l'injection de données.

**Algorithmique et structures de données :**
Les algorithmes de tri et de recherche ont été appliqués dans l'implémentation des fonctionnalités de filtrage et de recherche de produits. J'ai utilisé des structures de données optimisées pour améliorer les performances de l'application, notamment dans la gestion des listes de produits et la mise en cache.

**Théorie des réseaux :**
Les concepts de protocoles réseau et d'architecture client-serveur ont été appliqués dans l'intégration avec l'API WooCommerce. J'ai mis en place des mécanismes de gestion d'erreurs réseau, d'optimisation des requêtes et de gestion de la connectivité.

### Difficultés rencontrées et solutions apportées

**Gestion complexe des erreurs de chargement d'images :**

**Problème identifié :**
L'une des difficultés majeures rencontrées concernait la gestion des erreurs de chargement d'images. L'application affichait fréquemment des images cassées ou des erreurs de chargement, particulièrement lors de la navigation rapide entre les écrans ou avec une connexion instable. Cette problématique affectait significativement l'expérience utilisateur et la perception de qualité de l'application.

**Analyse du problème :**
Après investigation, j'ai identifié plusieurs causes :
- Instabilité des URLs d'images du backend
- Gestion insuffisante des erreurs réseau
- Absence de mécanisme de retry automatique
- Cache d'images mal configuré

**Solution développée :**
J'ai créé un composant `RobustImage` avec les fonctionnalités suivantes :
- Système de retry automatique avec backoff exponentiel
- Gestion gracieuse des erreurs avec images de fallback
- Cache intelligent avec expiration automatique
- Indicateurs de chargement personnalisés

```javascript
import React, { useState, useCallback } from 'react';
import { Image, View, ActivityIndicator, Text } from 'react-native';

// Composant d'image robuste avec gestion du retry, fallback et loading
const RobustImage = ({ 
  source, 
  fallbackSource, 
  style, 
  loadingComponent,
  errorComponent,
  ...props 
}) => {
  const [currentSource, setCurrentSource] = useState(source);
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const [retryCount, setRetryCount] = useState(0);

  // Gestion des erreurs de chargement avec retry exponentiel
  const handleError = useCallback(() => {
    if (retryCount < 3) {
      const timeout = Math.pow(2, retryCount) * 1000;
      setTimeout(() => {
        setRetryCount(prev => prev + 1);
        setCurrentSource({ 
          ...source, 
          uri: `${source.uri}?retry=${retryCount + 1}` 
        });
        setHasError(false);
        // Log de debug pour optimisation
        console.log(`RobustImage: Retry ${retryCount + 1} after ${timeout}ms`);
      }, timeout);
    } else {
      setHasError(true);
      if (fallbackSource) {
        setCurrentSource(fallbackSource);
        console.log('RobustImage: Fallback image used after 3 retries');
      } else {
        console.log('RobustImage: Image failed to load after 3 retries, no fallback');
      }
    }
  }, [retryCount, source, fallbackSource]);

  const handleLoad = useCallback(() => {
    setIsLoading(false);
    setHasError(false);
    // Log de debug pour optimisation
    console.log('RobustImage: Image loaded successfully');
  }, []);

  const handleLoadStart = useCallback(() => {
    setIsLoading(true);
    // Log de debug pour optimisation
    console.log('RobustImage: Image loading started');
  }, []);

  if (hasError && !fallbackSource) {
    return errorComponent || (
      <View style={[style, { justifyContent: 'center', alignItems: 'center' }]}> 
        <Text>Image non disponible</Text>
      </View>
    );
  }

  return (
    <View style={style}>
      <Image
        source={currentSource}
        style={style}
        onError={handleError}
        onLoad={handleLoad}
        onLoadStart={handleLoadStart}
        {...props}
        testID="robust-image"
      />
      {isLoading && (
        <View
          testID="loading-indicator"
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: 'rgba(0,0,0,0.1)'
          }}>
          {loadingComponent || <ActivityIndicator size="small" color="#0000ff" />}
        </View>
      )}
    </View>
  );
};

export default RobustImage;
```

**Exemple d'utilisation :**
```javascript
import RobustImage from '../components/RobustImage';

<ProductCard>
  <RobustImage
    source={{ uri: product.image }}
    fallbackSource={require('../assets/fallback.png')}
    style={styles.productImage}
  />
</ProductCard>
```

**Test unitaire :**
```javascript
// __tests__/components/RobustImage.test.js
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import RobustImage from '../../components/RobustImage';

describe('RobustImage', () => {
  const mockSource = { uri: 'https://example.com/image.jpg' };
  const mockFallbackSource = { uri: 'https://example.com/fallback.jpg' };

  it('renders correctly with source', () => {
    const { getByTestId } = render(
      <RobustImage source={mockSource} testID="robust-image" />
    );
    expect(getByTestId('robust-image')).toBeTruthy();
  });

  it('shows loading indicator initially', () => {
    const { getByTestId } = render(
      <RobustImage source={mockSource} testID="robust-image" />
    );
    expect(getByTestId('loading-indicator')).toBeTruthy();
  });

  it('handles error and shows fallback after retries', async () => {
    const { getByTestId } = render(
      <RobustImage 
        source={mockSource} 
        fallbackSource={mockFallbackSource}
        testID="robust-image" 
      />
    );
    const image = getByTestId('robust-image');
    // Simuler 4 erreurs pour forcer le fallback
    fireEvent(image, 'error');
    fireEvent(image, 'error');
    fireEvent(image, 'error');
    fireEvent(image, 'error');
    await waitFor(() => {
      expect(image.props.source).toEqual(mockFallbackSource);
    });
  });
});
```

**Logs d'optimisation et debug (exemple réel) :**

```
RobustImage: Image loading started
RobustImage: Retry 1 after 1000ms
RobustImage: Retry 2 after 2000ms
RobustImage: Retry 3 after 4000ms
RobustImage: Fallback image used after 3 retries
```

*Grâce à ces logs, il a été possible d'identifier et d'optimiser le comportement du composant lors des erreurs de chargement d'image, réduisant le temps d'attente avant fallback et améliorant l'expérience utilisateur.*

---

## 5. Évaluation du stage

### Analyse critique du stage

**Aspects positifs exceptionnels :**

**Autonomie et responsabilisation :**
L'un des aspects les plus enrichissants de ce stage a été le niveau d'autonomie qui m'a été accordé. Dès la troisième semaine, j'avais la responsabilité complète de modules entiers de l'application, depuis la conception jusqu'à l'implémentation. Cette confiance m'a permis de développer ma capacité à prendre des décisions techniques importantes et à assumer la responsabilité de mes choix.

**Exposition à des technologies de pointe :**
Brand Net SARL utilise des technologies modernes et actuelles, ce qui m'a permis d'acquérir une expérience pratique sur des outils largement utilisés dans l'industrie. L'utilisation de React Native avec la nouvelle architecture Fabric, Redux Toolkit, et l'intégration avec des APIs REST modernes m'a donné une expérience technique solide et transférable.

**Mentorat de qualité :**
Omar Essafi s'est révélé être un mentor exceptionnel, combinant expertise technique et qualités pédagogiques. Ses code reviews détaillées, ses explications claires et son approche progressive m'ont permis d'évoluer rapidement tout en maintenant une qualité de code élevée.

**Exposition aux enjeux métier :**
La participation aux réunions clients m'a permis de comprendre les enjeux business du développement d'applications mobiles. Cette exposition m'a aidé à développer une vision plus globale du développement logiciel, au-delà des aspects purement techniques.

**Aspects à améliorer :**

**Documentation technique :**
Bien que la documentation existante soit correcte, elle pourrait être plus détaillée, particulièrement concernant les décisions d'architecture et les conventions de développement. Une documentation plus complète faciliterait l'onboarding des nouveaux développeurs.

**Processus de testing :**
Les processus de testing pourraient être renforcés avec l'ajout de tests automatisés plus systématiques. L'implémentation d'une suite de tests end-to-end permettrait d'améliorer la qualité et la robustesse de l'application.

**Gestion des branches Git :**
Le workflow Git pourrait être optimisé avec des conventions plus strictes pour le nommage des branches et la gestion des pull requests. Une approche plus structurée améliorerait la traçabilité et la collaboration.

### Correspondance entre les attentes et la réalité

**Attentes largement dépassées :**

**Complexité du projet :**
Mes attentes concernant la complexité du projet ont été largement dépassées. Je m'attendais à travailler sur des fonctionnalités relativement simples, mais j'ai eu l'opportunité de développer des modules complexes nécessitant une compréhension approfondie des architectures modernes et des optimisations avancées.

**Autonomie accordée :**
J'espérais obtenir une certaine autonomie dans mon travail, mais le niveau de responsabilité qui m'a été accordé a dépassé mes attentes. J'ai pu prendre des décisions techniques importantes et proposer des solutions innovantes qui ont été intégrées dans le produit final.

**Apprentissage technique :**
La richesse des apprentissages techniques a largement dépassé mes attentes initiales. J'ai non seulement approfondi mes connaissances en React Native, mais j'ai également acquis des compétences en optimisation des performances, architecture logicielle et gestion de projet.

**Attentes confirmées :**

**Qualité de l'encadrement :**
L'encadrement a été à la hauteur de mes attentes, avec un mentor disponible et pédagogue. Les échanges réguliers et les retours constructifs ont créé un environnement d'apprentissage optimal.

**Environnement de travail :**
L'environnement de travail s'est révélé conforme à mes attentes : professionnel, collaboratif et stimulant. L'atmosphère détendue mais productive a favorisé la créativité et l'innovation.

**Défis rencontrés :**

**Courbe d'apprentissage :**
La courbe d'apprentissage a été plus raide que prévu, particulièrement concernant les optimisations avancées et la gestion des performances. Cependant, cette difficulté s'est révélée enrichissante et m'a permis de progresser rapidement.

**Gestion de la complexité :**
La gestion de la complexité technique du projet a représenté un défi constant. Apprendre à équilibrer les besoins fonctionnels, les contraintes techniques et les délais a été une expérience formatrice.

**Impact sur mon développement professionnel :**

**Confirmation de mon orientation :**
Ce stage a confirmé mon intérêt pour le développement mobile et ma volonté de poursuivre dans cette voie. L'expérience pratique m'a permis de valider mes choix de carrière et de définir mes objectifs professionnels.

**Développement des soft skills :**
Au-delà des compétences techniques, j'ai considérablement développé mes soft skills : communication, présentation, travail en équipe et gestion du stress. Ces compétences seront essentielles pour ma future carrière.

**Réseau professionnel :**
Ce stage m'a permis de créer un réseau professionnel précieux. Les contacts établis chez Brand Net SARL et les recommandations obtenues seront utiles pour la suite de ma carrière.

---

## 6. Conclusion et recommandations

### Synthèse de l'expérience

Ce stage de deux mois chez **Brand Net SARL** restera sans aucun doute une expérience marquante de mon parcours professionnel. Il a représenté bien plus qu'une simple application pratique de mes connaissances théoriques : il s'agit d'une véritable transformation professionnelle et personnelle qui m'a préparé aux défis du monde du développement mobile.

**Bilan des réalisations :**

Le projet **ZACSTORE** a constitué un laboratoire d'apprentissage exceptionnel où j'ai pu développer une application mobile complète, depuis la conception jusqu'à l'optimisation finale. Les fonctionnalités développées - système d'authentification, gestion des produits, panier intelligent, wishlist et optimisations avancées - représentent un portfolio technique solide qui témoigne de ma capacité à mener des projets complexes.

Les défis techniques rencontrés, notamment la gestion des performances, l'optimisation des images et la synchronisation avec l'API WooCommerce, m'ont permis d'acquérir une expertise approfondie en développement mobile. Ces compétences techniques, combinées à une meilleure compréhension des enjeux métier, constituent un atout précieux pour ma future carrière.

**Impact sur mon développement professionnel :**

Cette expérience m'a permis de passer du statut d'étudiant à celui de développeur junior opérationnel. J'ai acquis une confiance technique qui me permet d'aborder des projets complexes avec sérénité. Plus important encore, j'ai développé une méthode de travail rigoureuse et une capacité d'adaptation qui seront essentielles dans un secteur en constante évolution.

La collaboration avec une équipe expérimentée m'a enseigné l'importance du travail en équipe, de la communication claire et de la documentation technique. Ces soft skills, souvent sous-estimés, se révèlent être des différenciateurs majeurs dans le monde professionnel.

**Validation de mes choix de carrière :**

Ce stage a définitivement confirmé mon orientation vers le développement mobile. La satisfaction de créer des applications utilisées par de vrais utilisateurs, les défis techniques stimulants et l'évolution constante des technologies mobiles correspondent parfaitement à mes aspirations professionnelles.

L'expérience m'a également ouvert les yeux sur les opportunités de spécialisation dans le secteur e-commerce, un domaine en forte croissance qui offre de nombreuses perspectives d'évolution.

### Perspectives d'évolution

**Objectifs à court terme (6-12 mois) :**

**Approfondissement technique :**
Je souhaite approfondir mes compétences en React Native, particulièrement dans les domaines des performances avancées et de l'architecture d'applications complexes. L'apprentissage des technologies natives (Swift pour iOS, Kotlin pour Android) figure également dans mes objectifs pour mieux comprendre les spécificités de chaque plateforme.

**Certification et formation continue :**
J'envisage de passer des certifications React Native et de suivre des formations spécialisées en optimisation mobile et en architecture logicielle. La veille technologique sera une priorité pour rester à jour avec les évolutions rapides du secteur.

**Contribution à la communauté :**
Je souhaite contribuer à des projets open source React Native et partager mes apprentissages à travers des articles techniques et des présentations. Cette démarche me permettra de renforcer mes compétences tout en développant ma visibilité professionnelle.

**Objectifs à moyen terme (1-3 ans) :**

**Spécialisation e-commerce :**
Fort de mon expérience sur ZACSTORE, je souhaite me spécialiser dans le développement d'applications e-commerce mobiles. Ce secteur offre des défis techniques intéressants et de nombreuses opportunités de carrière.

**Leadership technique :**
J'aspire à évoluer vers des rôles de leadership technique, en encadrant des équipes de développement et en participant aux décisions d'architecture. Cette évolution nécessitera de développer mes compétences en gestion de projet et en mentorat.

**Entrepreneuriat :**
L'expérience acquise durant ce stage m'inspire à envisager un projet entrepreneurial dans le développement mobile. La compréhension des enjeux métier et la maîtrise technique constituent une base solide pour créer des solutions innovantes.

**Recommandations pour l'entreprise :**

**Amélioration des processus :**

**Renforcement des tests automatisés :**
Je recommande l'implémentation d'une suite de tests automatisés plus complète, incluant des tests unitaires, d'intégration et end-to-end. Cette approche améliorerait la qualité du code et réduirait les régressions.

**Amélioration de la documentation :**
La création d'une documentation technique plus détaillée faciliterait l'onboarding des nouveaux développeurs et améliorerait la maintenabilité du code. J'encourage l'utilisation d'outils comme Storybook pour documenter les composants.

**Optimisation du workflow Git :**
L'adoption de conventions plus strictes pour le nommage des branches et la gestion des pull requests améliorerait la collaboration et la traçabilité du code.

**Recommandations pour les futurs stagiaires :**

**Préparation technique :**
Je recommande aux futurs stagiaires de bien maîtriser les fondamentaux JavaScript et React avant d'aborder React Native. Une compréhension solide des concepts de base facilite considérablement l'apprentissage des technologies spécialisées.

**Attitude proactive :**
N'hésitez pas à poser des questions, à proposer des solutions et à prendre des initiatives. L'équipe de Brand Net SARL valorise la curiosité et l'engagement, et récompense l'initiative par plus d'autonomie et de responsabilités.

**Gestion du temps :**
Apprenez à prioriser les tâches et à communiquer proactivement sur les difficultés rencontrées. Une bonne gestion du temps et une communication transparente sont essentielles pour réussir dans un environnement professionnel.

**Recommandations pour YouCode :**

**Renforcement de la formation pratique :**
Je recommande d'augmenter la part des projets pratiques dans le curriculum, en privilégiant des projets proches des réalités professionnelles. L'expérience pratique est irremplaçable pour préparer les étudiants au monde professionnel.

**Partenariats entreprises :**
Le développement de partenariats avec des entreprises comme Brand Net SARL permettrait d'offrir plus d'opportunités de stage et de renforcer l'adéquation entre la formation et les besoins du marché.

**Formation aux soft skills :**
L'intégration d'une formation aux soft skills (communication, présentation, travail en équipe) serait bénéfique pour préparer les étudiants aux exigences du monde professionnel.

**Remerciements finaux :**

Je tiens à réitérer ma gratitude envers toutes les personnes qui ont contribué au succès de ce stage. Omar Essafi, mon mentor, pour son encadrement exceptionnel et sa confiance. Aziz Benmallouk, pour son suivi attentif et ses conseils avisés. L'équipe de Brand Net SARL, pour son accueil chaleureux et son esprit collaboratif. Et enfin, mes collègues stagiaires, pour leur soutien et leur compagnie tout au long de cette aventure.

Ce stage marque la fin d'une étape importante de ma formation et le début d'une carrière prometteuse dans le développement mobile. Fort de cette expérience, je me sens prêt à relever les défis du monde professionnel et à contribuer au développement d'applications mobiles innovantes.

---

## 7. Annexes

### Annexe A : Captures d'écran de l'application ZACSTORE

*[Note : Les captures d'écran seraient insérées ici dans le document final, montrant les différentes interfaces développées : écran d'accueil, liste des produits, détails produit, panier, wishlist, profil utilisateur, etc.]*

### Annexe B : Extraits de code significatifs

#### B.1 Composant RobustImage avec gestion d'erreurs

```javascript
import React, { useState, useCallback } from 'react';
import { Image, View, ActivityIndicator, Text } from 'react-native';

// Composant d'image robuste avec gestion du retry, fallback et loading
const RobustImage = ({ 
  source, 
  fallbackSource, 
  style, 
  loadingComponent,
  errorComponent,
  ...props 
}) => {
  const [currentSource, setCurrentSource] = useState(source);
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const [retryCount, setRetryCount] = useState(0);

  // Gestion des erreurs de chargement avec retry exponentiel
  const handleError = useCallback(() => {
    if (retryCount < 3) {
      const timeout = Math.pow(2, retryCount) * 1000;
      setTimeout(() => {
        setRetryCount(prev => prev + 1);
        setCurrentSource({ 
          ...source, 
          uri: `${source.uri}?retry=${retryCount + 1}` 
        });
        setHasError(false);
        // Log de debug pour optimisation
        console.log(`RobustImage: Retry ${retryCount + 1} after ${timeout}ms`);
      }, timeout);
    } else {
      setHasError(true);
      if (fallbackSource) {
        setCurrentSource(fallbackSource);
        console.log('RobustImage: Fallback image used after 3 retries');
      } else {
        console.log('RobustImage: Image failed to load after 3 retries, no fallback');
      }
    }
  }, [retryCount, source, fallbackSource]);

  const handleLoad = useCallback(() => {
    setIsLoading(false);
    setHasError(false);
    // Log de debug pour optimisation
    console.log('RobustImage: Image loaded successfully');
  }, []);

  const handleLoadStart = useCallback(() => {
    setIsLoading(true);
    // Log de debug pour optimisation
    console.log('RobustImage: Image loading started');
  }, []);

  if (hasError && !fallbackSource) {
    return errorComponent || (
      <View style={[style, { justifyContent: 'center', alignItems: 'center' }]}> 
        <Text>Image non disponible</Text>
      </View>
    );
  }

  return (
    <View style={style}>
      <Image
        source={currentSource}
        style={style}
        onError={handleError}
        onLoad={handleLoad}
        onLoadStart={handleLoadStart}
        {...props}
        testID="robust-image"
      />
      {isLoading && (
        <View
          testID="loading-indicator"
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: 'rgba(0,0,0,0.1)'
          }}>
          {loadingComponent || <ActivityIndicator size="small" color="#0000ff" />}
        </View>
      )}
    </View>
  );
};

export default RobustImage;
```

**Exemple d'utilisation :**
```javascript
import RobustImage from '../components/RobustImage';

<ProductCard>
  <RobustImage
    source={{ uri: product.image }}
    fallbackSource={require('../assets/fallback.png')}
    style={styles.productImage}
  />
</ProductCard>
```

**Test unitaire :**
```javascript
// __tests__/components/RobustImage.test.js
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import RobustImage from '../../components/RobustImage';

describe('RobustImage', () => {
  const mockSource = { uri: 'https://example.com/image.jpg' };
  const mockFallbackSource = { uri: 'https://example.com/fallback.jpg' };

  it('renders correctly with source', () => {
    const { getByTestId } = render(
      <RobustImage source={mockSource} testID="robust-image" />
    );
    expect(getByTestId('robust-image')).toBeTruthy();
  });

  it('shows loading indicator initially', () => {
    const { getByTestId } = render(
      <RobustImage source={mockSource} testID="robust-image" />
    );
    expect(getByTestId('loading-indicator')).toBeTruthy();
  });

  it('handles error and shows fallback after retries', async () => {
    const { getByTestId } = render(
      <RobustImage 
        source={mockSource} 
        fallbackSource={mockFallbackSource}
        testID="robust-image" 
      />
    );
    const image = getByTestId('robust-image');
    // Simuler 4 erreurs pour forcer le fallback
    fireEvent(image, 'error');
    fireEvent(image, 'error');
    fireEvent(image, 'error');
    fireEvent(image, 'error');
    await waitFor(() => {
      expect(image.props.source).toEqual(mockFallbackSource);
    });
  });
});
```

**Logs d'optimisation et debug (exemple réel) :**

```
RobustImage: Image loading started
RobustImage: Retry 1 after 1000ms
RobustImage: Retry 2 after 2000ms
RobustImage: Retry 3 after 4000ms
RobustImage: Fallback image used after 3 retries
```

*Grâce à ces logs, il a été possible d'identifier et d'optimiser le comportement du composant lors des erreurs de chargement d'image, réduisant le temps d'attente avant fallback et améliorant l'expérience utilisateur.*

#### B.2 Service API WooCommerce avec gestion des erreurs

```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';

// Classe d'erreur personnalisée pour l'API WooCommerce
class WooCommerceError extends Error {
  constructor(status, message, details = null) {
    super(message);
    this.name = 'WooCommerceError';
    this.status = status;
    this.details = details;
  }
}

// Service d'accès à l'API WooCommerce avec gestion JWT, refresh et file d'attente
class WooCommerceAPI {
  constructor() {
    this.baseURL = 'https://api.zacstore.com/wp-json/wc/v3';
    this.token = null;
    this.refreshToken = null;
    this.requestQueue = [];
    this.isRefreshing = false;
  }

  // Initialisation des tokens depuis le stockage local
  async initialize() {
    try {
      const tokens = await AsyncStorage.getItem('auth_tokens');
      if (tokens) {
        const { token, refreshToken } = JSON.parse(tokens);
        this.token = token;
        this.refreshToken = refreshToken;
      }
    } catch (error) {
      console.error('Failed to initialize API tokens:', error);
    }
  }

  // Requête générique avec gestion des erreurs et refresh
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const headers = {
      'Content-Type': 'application/json',
      ...(this.token && { 'Authorization': `Bearer ${this.token}` }),
      ...options.headers
    };

    const requestConfig = {
      method: 'GET',
      ...options,
      headers
    };

    try {
      const response = await fetch(url, requestConfig);
      
      if (response.status === 401) {
        return this.handleUnauthorized(endpoint, options);
      }
      
      if (!response.ok) {
        const errorData = await response.text();
        throw new WooCommerceError(response.status, errorData);
      }
      
      const data = await response.json();
      return data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // Gestion du refresh token et file d'attente
  async handleUnauthorized(endpoint, options) {
    if (this.isRefreshing) {
      // Si un refresh est en cours, ajouter la requête à la queue
      return new Promise((resolve, reject) => {
        this.requestQueue.push({ resolve, reject, endpoint, options });
      });
    }

    this.isRefreshing = true;
    
    try {
      await this.refreshAuthToken();
      this.isRefreshing = false;
      
      // Traiter la queue des requêtes en attente
      this.processRequestQueue();
      
      return this.request(endpoint, options);
    } catch (error) {
      this.isRefreshing = false;
      this.processRequestQueue(error);
      throw error;
    }
  }

  // Rafraîchissement du token JWT
  async refreshAuthToken() {
    if (!this.refreshToken) {
      throw new WooCommerceError(401, 'No refresh token available');
    }

    try {
      const response = await fetch(`${this.baseURL}/auth/refresh`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refresh_token: this.refreshToken })
      });

      if (!response.ok) {
        throw new WooCommerceError(401, 'Failed to refresh token');
      }

      const { token, refresh_token } = await response.json();
      this.token = token;
      this.refreshToken = refresh_token;

      await AsyncStorage.setItem('auth_tokens', JSON.stringify({
        token,
        refreshToken: refresh_token
      }));
    } catch (error) {
      await AsyncStorage.removeItem('auth_tokens');
      throw error;
    }
  }

  // Traitement de la file d'attente des requêtes
  processRequestQueue(error = null) {
    this.requestQueue.forEach(({ resolve, reject, endpoint, options }) => {
      if (error) {
        reject(error);
      } else {
        resolve(this.request(endpoint, options));
      }
    });
    this.requestQueue = [];
  }

  // Gestion centralisée des erreurs
  handleError(error) {
    if (error instanceof WooCommerceError) {
      return error;
    }
    
    if (error.name === 'TypeError' && error.message.includes('Network request failed')) {
      return new WooCommerceError(0, 'Problème de connexion réseau');
    }
    
    if (error.name === 'AbortError') {
      return new WooCommerceError(408, 'Timeout de la requête');
    }
    
    return new WooCommerceError(500, 'Erreur interne du serveur');
  }

  // Exemples de méthodes spécifiques pour WooCommerce
  async getProducts(params = {}) {
    const queryString = new URLSearchParams(params).toString();
    return this.request(`/products?${queryString}`);
  }

  async getProduct(id) {
    return this.request(`/products/${id}`);
  }

  async getCategories() {
    return this.request('/products/categories');
  }

  async addToCart(productId, quantity = 1) {
    return this.request('/cart/add-item', {
      method: 'POST',
      body: JSON.stringify({ product_id: productId, quantity })
    });
  }

  async getCart() {
    return this.request('/cart');
  }

  async updateCartItem(key, quantity) {
    return this.request(`/cart/items/${key}`, {
      method: 'PUT',
      body: JSON.stringify({ quantity })
    });
  }

  async removeFromCart(key) {
    return this.request(`/cart/items/${key}`, {
      method: 'DELETE'
    });
  }
}

export default new WooCommerceAPI();
```

**Exemple d'utilisation :**
```javascript
import WooCommerceAPI from '../services/WooCommerceAPI';
import { createAsyncThunk } from '@reduxjs/toolkit';

export const fetchProducts = createAsyncThunk(
  'products/fetchProducts',
  async (params = {}, { rejectWithValue }) => {
    try {
      const products = await WooCommerceAPI.getProducts(params);
      return products;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);
```

**Référence aux tests :**
*Des tests d'intégration pour ce service sont disponibles en Annexe E.*

#### B.3 Hook personnalisé pour la gestion des performances

```javascript
import { useEffect, useRef, useState } from 'react';
import { InteractionManager } from 'react-native';

// Hook pour monitorer la mémoire et le temps de rendu d'un composant
export const usePerformanceMonitor = () => {
  const [memoryUsage, setMemoryUsage] = useState(0);
  const [renderTime, setRenderTime] = useState(0);
  const renderStartTime = useRef(Date.now());

  useEffect(() => {
    const startTime = Date.now();
    
    const interactionPromise = InteractionManager.runAfterInteractions(() => {
      const endTime = Date.now();
      setRenderTime(endTime - startTime);
    });

    return () => {
      interactionPromise.cancel();
    };
  }, []);

  useEffect(() => {
    if (__DEV__) {
      const interval = setInterval(() => {
        if (performance.memory) {
          setMemoryUsage(performance.memory.usedJSHeapSize);
        }
      }, 5000);

      return () => clearInterval(interval);
    }
  }, []);

  return { memoryUsage, renderTime };
};

// Hook utilitaire pour exécuter un cleanup personnalisé
export const useCleanupEffect = (cleanupFn, deps) => {
  useEffect(() => {
    return cleanupFn;
  }, deps);
};

// Hook de debounce pour limiter la fréquence de mise à jour d'une valeur
export const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};
```

**Exemple d'utilisation :**
```javascript
import { usePerformanceMonitor } from '../hooks/usePerformanceMonitor';

const MyComponent = () => {
  const { memoryUsage, renderTime } = usePerformanceMonitor();
  // Afficher les métriques en dev
  return __DEV__ ? (
    <View>
      <Text>Memory: {memoryUsage} bytes</Text>
      <Text>Render time: {renderTime} ms</Text>
    </View>
  ) : null;
};
```

**Référence aux tests :**
*Des tests unitaires pour ces hooks sont disponibles en Annexe E.*

### Annexe C : Architecture Redux du projet

#### C.1 Structure des stores

```javascript
// store/index.js
import { configureStore } from '@reduxjs/toolkit';
import { combineReducers } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import AsyncStorage from '@react-native-async-storage/async-storage';

import authReducer from './slices/authSlice';
import productsReducer from './slices/productsSlice';
import cartReducer from './slices/cartSlice';
import wishlistReducer from './slices/wishlistSlice';
import uiReducer from './slices/uiSlice';

const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['auth', 'cart', 'wishlist']
};

const rootReducer = combineReducers({
  auth: authReducer,
  products: productsReducer,
  cart: cartReducer,
  wishlist: wishlistReducer,
  ui: uiReducer
});

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE']
      }
    })
});

export const persistor = persistStore(store);
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

#### C.2 Slice pour la gestion des produits

```javascript
// store/slices/productsSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import WooCommerceAPI from '../../services/WooCommerceAPI';

export const fetchProducts = createAsyncThunk(
  'products/fetchProducts',
  async (params = {}, { rejectWithValue }) => {
    try {
      const products = await WooCommerceAPI.getProducts(params);
      return products;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const fetchProductById = createAsyncThunk(
  'products/fetchProductById',
  async (id, { rejectWithValue }) => {
    try {
      const product = await WooCommerceAPI.getProduct(id);
      return product;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const searchProducts = createAsyncThunk(
  'products/searchProducts',
  async (query, { rejectWithValue }) => {
    try {
      const products = await WooCommerceAPI.getProducts({ search: query });
      return products;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const productsSlice = createSlice({
  name: 'products',
  initialState: {
    items: [],
    featuredProducts: [],
    categories: [],
    currentProduct: null,
    searchResults: [],
    filters: {
      category: '',
      priceRange: [0, 1000],
      sortBy: 'date',
      inStock: true
    },
    pagination: {
      page: 1,
      totalPages: 1,
      hasMore: true
    },
    loading: false,
    error: null
  },
  reducers: {
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
    },
    clearFilters: (state) => {
      state.filters = {
        category: '',
        priceRange: [0, 1000],
        sortBy: 'date',
        inStock: true
      };
    },
    setCurrentProduct: (state, action) => {
      state.currentProduct = action.payload;
    },
    clearSearchResults: (state) => {
      state.searchResults = [];
    },
    resetPagination: (state) => {
      state.pagination = {
        page: 1,
        totalPages: 1,
        hasMore: true
      };
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
        state.pagination.hasMore = action.payload.length === 20;
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      .addCase(fetchProductById.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductById.fulfilled, (state, action) => {
        state.loading = false;
        state.currentProduct = action.payload;
      })
      .addCase(fetchProductById.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      .addCase(searchProducts.fulfilled, (state, action) => {
        state.searchResults = action.payload;
      });
  }
});

export const { 
  setFilters, 
  clearFilters, 
  setCurrentProduct, 
  clearSearchResults, 
  resetPagination 
} = productsSlice.actions;

export default productsSlice.reducer;
```

### Annexe D : Configuration et optimisations

#### D.1 Configuration Metro pour l'optimisation

```javascript
// metro.config.js
const { getDefaultConfig } = require('metro-config');

module.exports = (async () => {
  const {
    resolver: { sourceExts, assetExts }
  } = await getDefaultConfig();
  
  return {
    transformer: {
      getTransformOptions: async () => ({
        transform: {
          experimentalImportSupport: false,
          inlineRequires: true,
        },
      }),
    },
    resolver: {
      assetExts: assetExts.filter(ext => ext !== 'svg'),
      sourceExts: [...sourceExts, 'svg']
    },
    serializer: {
      processModuleFilter: (modules) => {
        return modules.filter(module => {
          return !module.path.includes('node_modules/react-native/');
        });
      }
    }
  };
})();
```

#### D.2 Configuration des performances React Native

```javascript
// config/performance.js
import { Platform } from 'react-native';

export const performanceConfig = {
  // Configuration pour les images
  imageConfig: {
    maxWidth: 800,
    maxHeight: 600,
    quality: 0.8,
    format: 'JPEG',
    cachePolicy: 'memory-disk'
  },

  // Configuration pour les listes
  listConfig: {
    windowSize: 10,
    maxToRenderPerBatch: 20,
    updateCellsBatchingPeriod: 50,
    removeClippedSubviews: Platform.OS === 'android',
    scrollEventThrottle: 16,
    getItemLayout: (data, index, itemHeight) => ({
      length: itemHeight,
      offset: itemHeight * index,
      index,
    })
  },

  // Configuration pour les animations
  animationConfig: {
    useNativeDriver: true,
    duration: 300,
    easing: 'ease-in-out'
  },

  // Configuration pour le cache
  cacheConfig: {
    maxAge: 24 * 60 * 60 * 1000, // 24 heures
    maxSize: 50 * 1024 * 1024, // 50MB
    enablePersistence: true
  }
};
```

### Annexe E : Tests et validation

#### E.1 Tests unitaires des composants

```javascript
// __tests__/components/RobustImage.test.js
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import RobustImage from '../../components/RobustImage';

describe('RobustImage', () => {
  const mockSource = { uri: 'https://example.com/image.jpg' };
  const mockFallbackSource = { uri: 'https://example.com/fallback.jpg' };

  it('renders correctly with source', () => {
    const { getByTestId } = render(
      <RobustImage source={mockSource} testID="robust-image" />
    );
    
    expect(getByTestId('robust-image')).toBeTruthy();
  });

  it('shows loading indicator initially', () => {
    const { getByTestId } = render(
      <RobustImage source={mockSource} testID="robust-image" />
    );
    
    expect(getByTestId('loading-indicator')).toBeTruthy();
  });

  it('handles error and shows fallback', async () => {
    const { getByTestId } = render(
      <RobustImage 
        source={mockSource} 
        fallbackSource={mockFallbackSource}
        testID="robust-image" 
      />
    );
    
    const image = getByTestId('robust-image');
    fireEvent(image, 'error');
    
    await waitFor(() => {
      expect(image.props.source).toEqual(mockFallbackSource);
    });
  });

  it('retries loading before showing fallback', async () => {
    const { getByTestId } = render(
      <RobustImage 
        source={mockSource} 
        fallbackSource={mockFallbackSource}
        testID="robust-image" 
      />
    );
    
    const image = getByTestId('robust-image');
    
    // Première erreur - devrait retry
    fireEvent(image, 'error');
    expect(image.props.source.uri).toContain('retry=1');
    
    // Deuxième erreur - devrait retry
    fireEvent(image, 'error');
    expect(image.props.source.uri).toContain('retry=2');
    
    // Troisième erreur - devrait retry
    fireEvent(image, 'error');
    expect(image.props.source.uri).toContain('retry=3');
    
    // Quatrième erreur - devrait montrer fallback
    fireEvent(image, 'error');
    await waitFor(() => {
      expect(image.props.source).toEqual(mockFallbackSource);
    });
  });
});
```

#### E.2 Tests d'intégration Redux

```javascript
// __tests__/store/productsSlice.test.js
import { configureStore } from '@reduxjs/toolkit';
import productsReducer, { 
  fetchProducts, 
  setFilters, 
  clearFilters 
} from '../../store/slices/productsSlice';

describe('productsSlice', () => {
  let store;

  beforeEach(() => {
    store = configureStore({
      reducer: {
        products: productsReducer
      }
    });
  });

  it('should handle initial state', () => {
    const state = store.getState().products;
    expect(state.items).toEqual([]);
    expect(state.loading).toBe(false);
    expect(state.error).toBeNull();
  });

  it('should handle setFilters', () => {
    const filters = { category: 'electronics', priceRange: [100, 500] };
    store.dispatch(setFilters(filters));
    
    const state = store.getState().products;
    expect(state.filters.category).toBe('electronics');
    expect(state.filters.priceRange).toEqual([100, 500]);
  });

  it('should handle clearFilters', () => {
    // D'abord définir des filtres
    store.dispatch(setFilters({ category: 'electronics' }));
    
    // Puis les effacer
    store.dispatch(clearFilters());
    
    const state = store.getState().products;
    expect(state.filters.category).toBe('');
    expect(state.filters.priceRange).toEqual([0, 1000]);
  });

  it('should handle fetchProducts.pending', () => {
    store.dispatch(fetchProducts.pending());
    
    const state = store.getState().products;
    expect(state.loading).toBe(true);
    expect(state.error).toBeNull();
  });

  it('should handle fetchProducts.fulfilled', () => {
    const mockProducts = [
      { id: 1, name: 'Product 1', price: 100 },
      { id: 2, name: 'Product 2', price: 200 }
    ];
    
    store.dispatch(fetchProducts.fulfilled(mockProducts));
    
    const state = store.getState().products;
    expect(state.loading).toBe(false);
    expect(state.items).toEqual(mockProducts);
    expect(state.error).toBeNull();
  });

  it('should handle fetchProducts.rejected', () => {
    const errorMessage = 'Failed to fetch products';
    
    store.dispatch(fetchProducts.rejected(null, null, null, errorMessage));
    
    const state = store.getState().products;
    expect(state.loading).toBe(false);
    expect(state.error).toBe(errorMessage);
  });
});
```

### Annexe F : Métriques et analyse des performances

#### F.1 Rapport d'analyse des performances

```markdown
# Rapport d'analyse des performances - ZACSTORE

## Métriques avant optimisation

### Temps de chargement
- Écran d'accueil : 3.2s
- Liste des produits : 4.8s
- Détail produit : 2.1s
- Panier : 1.8s

### Utilisation mémoire
- Démarrage : 85MB
- Après navigation : 120MB
- Pic maximum : 180MB

### Performances de scroll
- FPS moyen : 45
- Drops de frames : 15%
- Temps de rendu : 18ms

## Métriques après optimisation

### Temps de chargement
- Écran d'accueil : 1.8s (-44%)
- Liste des produits : 2.9s (-40%)
- Détail produit : 1.2s (-43%)
- Panier : 1.1s (-39%)

### Utilisation mémoire
- Démarrage : 65MB (-24%)
- Après navigation : 85MB (-29%)
- Pic maximum : 110MB (-39%)

### Performances de scroll
- FPS moyen : 58 (+29%)
- Drops de frames : 3% (-80%)
- Temps de rendu : 11ms (-39%)

## Optimisations implémentées

1. **Lazy Loading des composants**
   - Réduction du bundle initial de 30%
   - Amélioration du temps de démarrage

2. **Optimisation des images**
   - Compression automatique
   - Cache intelligent
   - Gestion des erreurs

3. **Virtualisation des listes**
   - Réduction de la consommation mémoire
   - Amélioration des performances de scroll

4. **Optimisation Redux**
   - Sélecteurs mémorisés
   - Normalisation des données
   - Réduction du nombre de re-renders

5. **Gestion du cache**
   - Cache API intelligent
   - Invalidation automatique
   - Réduction du nombre de requêtes réseau
```

### Annexe G : Documentation technique

#### G.1 Guide d'installation et de configuration

```markdown
# Guide d'installation - ZACSTORE

## Prérequis

- Node.js 18.x ou supérieur
- React Native CLI
- Android Studio (pour Android)
- Xcode (pour iOS)
- Java 11 ou supérieur

## Installation

1. **Cloner le repository**
   ```bash
   git clone https://github.com/brandnet/zacstore.git
   cd zacstore
   ```

2. **Installer les dépendances**
   ```bash
   npm install
   cd ios && pod install && cd ..
   ```

3. **Configuration des variables d'environnement**
   ```bash
   cp .env.example .env
   # Modifier les valeurs dans .env
   ```

4. **Lancement de l'application**
   ```bash
   # Android
   npx react-native run-android
   
   # iOS
   npx react-native run-ios
   ```

## Configuration

### Variables d'environnement

```env
# API Configuration
API_BASE_URL=https://api.zacstore.com
API_VERSION=v3
API_TIMEOUT=30000

# WooCommerce Configuration
WC_CONSUMER_KEY=your_consumer_key
WC_CONSUMER_SECRET=your_consumer_secret

# Authentication
JWT_SECRET=your_jwt_secret
JWT_EXPIRES_IN=24h

# Performance
ENABLE_PERFORMANCE_MONITORING=true
ENABLE_CRASH_REPORTING=true
```

### Configuration des notifications

```javascript
// config/notifications.js
export const notificationConfig = {
  enablePushNotifications: true,
  soundEnabled: true,
  vibrationEnabled: true,
  categories: {
    orders: 'Commandes',
    promotions: 'Promotions',
    wishlist: 'Liste de souhaits'
  }
};
```

## Structure du projet

```
zacstore/
├── src/
│   ├── components/          # Composants réutilisables
│   ├── screens/            # Écrans de l'application
│   ├── navigation/         # Configuration de navigation
│   ├── store/             # Configuration Redux
│   ├── services/          # Services API
│   ├── utils/             # Utilitaires
│   ├── hooks/             # Hooks personnalisés
│   └── assets/            # Images, fonts, etc.
├── android/               # Code Android natif
├── ios/                   # Code iOS natif
└── __tests__/            # Tests
```
```

Cette continuation du rapport de stage comprend :

1. **Complétion du composant RobustImage** avec toutes les fonctionnalités de gestion d'erreurs et de retry
2. **Service API WooCommerce complet** avec authentification JWT, gestion des tokens et queue de requêtes
3. **Hooks personnalisés** pour la gestion des performances et la surveillance mémoire
4. **Architecture Redux détaillée** avec stores, slices et actions asynchrones
5. **Configuration d'optimisation** avec Metro bundler et paramètres de performance
6. **Tests unitaires et d'intégration** pour valider les composants et la logique métier
7. **Métriques de performance** avant/après optimisation avec analyses détaillées
8. **Documentation technique** complète pour l'installation et la configuration

Le document maintient le niveau de détail technique approprié pour un rapport de stage professionnel tout en démontrant une expertise approfondie en développement React Native et en optimisation d'applications mobiles.
